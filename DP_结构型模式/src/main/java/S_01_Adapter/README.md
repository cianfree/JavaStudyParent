#适配器模式
    Adapter 模式解决的问题在生活中经常会遇到：比如我们有一个 Team 为外界提供 S 类
    服务，但是我们 Team 里面没有能够完成此项人物的 member，然后我们得知有 A 可以完成
    这项服务（他把这项人物重新取了个名字叫 S’，并且他不对外公布他的具体实现） 。为了保
    证我们对外的服务类别的一致性（提供 S 服务） ，我们有以下两种方式解决这个问题：
    1）把 B 君直接招安到我们 Team 为我们工作，提供 S 服务的时候让 B 君去办就是了；
    2）B 君可能在别的地方有工作，并且不准备接受我们的招安，于是我们 Team 可以想
    这样一种方式解决问题：我们安排 C 君去完成这项任务，并做好工作（Money： ） ）让 A 君
    工作的时候可以向 B 君请教，因此 C 君就是一个复合体（提供 S 服务，但是是 B 君的继承
    弟子） 。
    实际上在软件系统设计和开发中， 这种问题也会经常遇到： 我们为了完成某项工作购买
    第 39 页 共 171 页 k_eckel
    设计模式精解－GoF 23 种设计模式解析附 C++实现源码 http://www.mscenter.edu.cn/blog/k_eckel
    了一个第三方的库来加快开发。 这就带来了一个问题： 我们在应用程序中已经设计好了接口，
    与这个第三方提供的接口不一致，为了使得这些接口不兼容的类（不能在一起工作）可以在
    一起工作了，Adapter 模式提供了将一个类（第三方库）的接口转化为客户（购买使用者）
    希望的接口。
    在上面生活中问题的解决方式也就正好对应了 Adapter 模式的两种类别：
    1) 类模式
        继承
    2) 对象模式
        组合，推荐使用

    Adapter 模式提供了将一个类（第三方库）的接口转化为客户（购买使用者）
    希望的接口

#Java LIB
    java.io.InputStreamReader(InputStream) (returns a Reader)
    java.io.OutputStreamWriter(OutputStream) (returns a Writer)


